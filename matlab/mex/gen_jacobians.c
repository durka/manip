#include <string.h>
#include <math.h>
#include "mex.h"

/*
 * gen_jacobians.c
 *
 * Generated by Matlab and then edited
 *
 * Written by Alex Burka, December 2012
 * University of Pennsylvania, GRASP Lab
 */

void Dq_3(double *ur, double *vr, double *Dq);
void Dq_2(double *ur, double *vr, double *Dq);
void Dr_3(double *ut, double *vt, double *Dr);
void Dr_2(double *ut, double *vt, double *Dr);

/* steps taken to generate this (do these for Dq, Dr, dims=2 and dims=3 and combine the files)
   1. make Matlab function
      A = sym('a%d%d', [dims dims]); A = sym(A, 'real');
      B = sym('b%d%d', [dims dims]); B = sym(B, 'real');
      s = evalc('simplify(jacobian(2*acos((trace(A\B)-1)/2), A))');
      Dq = eval(sprintf('@(ur, vr) %s', regexprep(subsref(regexp(s, '\n', 'split'), substruct('{}', {4})), {'a(\d)(\d)', 'b(\d)(\d)'}, {'ur($1,$2)', 'vr($1,$2)'})));
   2. translate to C
      ur = sym('ur_%d_%d', [dims dims]); ur = sym(ur, 'real');
      vr = sym('vr_%d_%d', [dims dims]); vr = sym(vr, 'real');
      ccode(Dq(ur,vr), 'file', 'mex/gen_Dq.c')
   3. regular expressions
      s/MatrixWithNoName/Dq/g    (Dq or Dr)
      s/\([uv]r\)_\(\d\)_\(\d\)/\=join(['IJ(', submatch(1), ',dims,', submatch(2)-1, ',', submatch(3)-1, ')'], '')/g    (replace dims with 2 and 3)
   4. put the necessary mex scaffolding around it (functions, declare variables, etc)
 */

#define IJ(m,n,i,j) ((m)[(i) + (n)*(j)])

void Dq_3(double *ur, double *vr, double *Dq)
{
    double t142, t143, t144, t145, t146, t147, t148, t149, t150, t151, t152, t153, t154, t155;
    // BEGIN GENERATED CODE
        t142 = IJ(ur,3,0,0)*IJ(vr,3,0,0)*(1.0/2.0);
        t143 = IJ(ur,3,0,1)*IJ(vr,3,0,1)*(1.0/2.0);
        t144 = IJ(ur,3,1,0)*IJ(vr,3,1,0)*(1.0/2.0);
        t145 = IJ(ur,3,0,2)*IJ(vr,3,0,2)*(1.0/2.0);
        t146 = IJ(ur,3,1,1)*IJ(vr,3,1,1)*(1.0/2.0);
        t147 = IJ(ur,3,2,0)*IJ(vr,3,2,0)*(1.0/2.0);
        t148 = IJ(ur,3,1,2)*IJ(vr,3,1,2)*(1.0/2.0);
        t149 = IJ(ur,3,2,1)*IJ(vr,3,2,1)*(1.0/2.0);
        t150 = IJ(ur,3,2,2)*IJ(vr,3,2,2)*(1.0/2.0);
        t151 = t142+t143+t144+t145+t146+t147+t148+t149+t150-1.0/2.0;
        t152 = acos(t151);
        t153 = t151*t151;
        t154 = -t153+1.0;
        t155 = 1.0/sqrt(t154);
        Dq[0] = t152*t155*IJ(vr,3,0,0)*-2.0;
        Dq[1] = t152*t155*IJ(vr,3,1,0)*-2.0;
        Dq[2] = t152*t155*IJ(vr,3,2,0)*-2.0;
        Dq[3] = t152*t155*IJ(vr,3,0,1)*-2.0;
        Dq[4] = t152*t155*IJ(vr,3,1,1)*-2.0;
        Dq[5] = t152*t155*IJ(vr,3,2,1)*-2.0;
        Dq[6] = t152*t155*IJ(vr,3,0,2)*-2.0;
        Dq[7] = t152*t155*IJ(vr,3,1,2)*-2.0;
        Dq[8] = t152*t155*IJ(vr,3,2,2)*-2.0;
    // END GENERATED CODE
}

void Dq_2(double *ur, double *vr, double *Dq)
{
    double t132, t133, t134, t135, t136, t137, t138, t139, t140;
    // BEGIN GENERATED CODE
        t132 = IJ(ur,2,0,0)*IJ(vr,2,0,0)*(1.0/2.0);
        t133 = IJ(ur,2,0,1)*IJ(vr,2,0,1)*(1.0/2.0);
        t134 = IJ(ur,2,1,0)*IJ(vr,2,1,0)*(1.0/2.0);
        t135 = IJ(ur,2,1,1)*IJ(vr,2,1,1)*(1.0/2.0);
        t136 = t132+t133+t134+t135-1.0/2.0;
        t137 = acos(t136);
        t138 = t136*t136;
        t139 = -t138+1.0;
        t140 = 1.0/sqrt(t139);
        Dq[0] = t137*t140*IJ(vr,2,0,0)*-2.0;
        Dq[1] = t137*t140*IJ(vr,2,1,0)*-2.0;
        Dq[2] = t137*t140*IJ(vr,2,0,1)*-2.0;
        Dq[3] = t137*t140*IJ(vr,2,1,1)*-2.0;
    // END GENERATED CODE
}

void Dr_3(double *ut, double *vt, double *Dr)
{
    // BEGIN GENERATED CODE
        Dr[0] = ut[0]*2.0-vt[0]*2.0;
        Dr[1] = ut[1]*2.0-vt[1]*2.0;
        Dr[2] = ut[2]*2.0-vt[2]*2.0;
    // END GENERATED CODE
}

void Dr_2(double *ut, double *vt, double *Dr)
{
    // BEGIN GENERATED CODE
        Dr[0] = ut[0]*2.0-vt[0]*2.0;
        Dr[1] = ut[1]*2.0-vt[1]*2.0;
    // END GENERATED CODE
}

void mexFunction( int nlhs, mxArray *plhs[],
                  int nrhs, const mxArray *prhs[] )
{
    const mxArray *u, *v;
    double *uu, *vv, *out;
    size_t m, n;
    void (*funcs[2][3])(double *, double *, double *) = { {Dr_2, Dq_2}, {Dr_3, NULL, Dq_3} };

    /* Check for proper number of arguments. */
    if (nrhs!=2) {
        mexErrMsgTxt("Two inputs required.");
    } else if (nlhs>1) {
        mexErrMsgTxt("Too many output arguments.");
    }

    u = prhs[0];
    v = prhs[1];

    /* Check argument types */
    if (!mxIsDouble(u) || mxIsComplex(u) || mxGetNumberOfDimensions(u) != 2
     || !mxIsDouble(v) || mxIsComplex(v) || mxGetNumberOfDimensions(v) != 2) {
        mexErrMsgTxt("Inputs must be real double 2D arrays.");
    }

    /* Decide what to do based on argument sizes */
    m = mxGetM(u);
    n = mxGetN(u);
    if (mxGetM(v) != m || mxGetN(v) != n) {
        mexErrMsgTxt("Inputs must have the same size.");
    }
    if ((m != 2 && m != 3)
     || (n != m && n != 1)) {
        mexErrMsgTxt("Permissible input sizes: 2x2, 2x1, 3x3, 3x1");
    }

    plhs[0] = mxCreateDoubleMatrix(1, m*n, mxREAL);
    uu = mxGetPr(u);
    vv = mxGetPr(v);
    out = mxGetPr(plhs[0]);
    funcs[m-2][n-1](uu, vv, out);

    // HACK to get around NaNs
    if (isnan(out[0])) {
        unsigned i, j;
        double eps = 10*DBL_EPSILON;

        //printf("[GJ] fuck! try adding\n");
        for (i = 0; i < m; ++i) {
            for (j = 0; j < n; ++j) {
                IJ(vv,m,i,j) += eps;
            }
        }
        funcs[m-2][n-1](uu, vv, out);
        for (i = 0; i < m; ++i) {
            for (j = 0; j < n; ++j) {
                IJ(vv,m,i,j) -= eps;
            }
        }

        if (isnan(out[0])) {
            //printf("[GJ] fuck! try subtracting\n");
            for (i = 0; i < m; ++i) {
                for (j = 0; j < n; ++j) {
                    IJ(vv,m,i,j) -= eps;
                }
            }
            funcs[m-2][n-1](uu, vv, out);
            for (i = 0; i < m; ++i) {
                for (j = 0; j < n; ++j) {
                    IJ(vv,m,i,j) += eps;
                }
            }
        }
    }

}

